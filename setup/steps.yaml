description: |
  ![divider](https://platform.sh/images/cta/bg-contact.svg?sanitize=true)

  # GitHub/Probot App Template for Platform.sh

  This is a basic template for setting up a production-ready GitHub App using Probot on Platform.sh.

  Once the template is initialized, the installer will direct you to register the app with GitHub. After that, it is set up to leave a welcome message comment on each newly opened issue for each repository it has been installed on.

  Afterwards, you can update the template to perform more actions using the GitHub API, including adding additional permissions.

issue_opened_dev: |

  ![divider](https://platform.sh/images/linked-block/bunny-carrots.svg?sanitize=true)

  <p><h3 align="center">Success! <br><br>You've deployed another GitHub App from Platform.sh<br>this time, for development.</h3></p><br>

  Adds steps here for merge.

issue_opened: |
  ![divider](https://platform.sh/images/cta/hands.svg?sanitize=true)

  <p><h3 align="center">Success! <br><br>You've deployed your first GitHub App <br>using Probot on Platform.sh!</h3></p><br>

  ### Final production setup

  We have one final step to set up our production GitHub application on Platform.sh, and it all has to do with development environments. Ideally, we want to keep our configuration set for the `master` environment of our app, but have the ability to register and create a new app to run a staging and/or development version to test new features.

  In order to ensure that none of the configurations we create on these development environments override our production configuration, we'll need to set the variables defined in your `.env` file as [environment variables](https://docs.platform.sh/configuration/app/variables.html) on your Platform.sh `master` environment.

  ```bash
  platform variable:create env:AUTHOR --level project --value Juan
  ```

  Until you do so, the `.env` file can be overwritten by anyone with access to that environment.

  ### Next steps

  Now that you're registered on GitHub and have installed the app on this repository, you can see how Platform.sh development environments can help you test updates to your application.

  1. **Update `.environment` on a new branch**

       At the end of our `master` setup, we set `NODE_ENV=production` so that it could start receiving deliveries from GitHub. Our `updates` environment will be its own webhook proxy, and it will need to be registered as its own GitHub App in order for us to test. For now, set the environment to `development` and commit it.

       ```
       cd <PROJECT NAME>
       git checkout -b updates
       echo 'export NODE_ENV="development"' > .environment
       git add .environment && git commit -m "Set NODE_ENV to development to register."
       ```

  3. **Update the application**

       The template application comes by default with the following permissions:

       ```yaml
       default_events:
          - issues
       default_permissions:
          issues: write
          metadata: read
       ```

       As you can see, its permissions are restricted to *Read/Write access to Issues*, and nothing else. Let's say that I want to add more features to my application, and also be able to test them on their own GitHub App.

       Comment out the following line in your `app.yml` file, which updates the app's permissions to include read-access to `pull_requests`:

      ```yaml
      default_permissions:

        ...

        # Pull requests and related comments, assignees, labels, milestones, and merges.
        # https://developer.github.com/v3/apps/permissions/#permission-on-pull-requests
        pull_requests: read
      ```

      We're not going to add anything to the app now that uses `pull_requests`, but we will make one small additional change. In your `index.js` file, update the issue comment body to use the value `issue_opened_dev`:

      ```
      app.on('issues.opened', async context => {
        const issueComment = context.issue({ body: platformsh.issue_opened_dev })
        return context.github.issues.createComment(issueComment)
      })
      ```

  4. **Push the update and verify**

      Add and commit the changes and push the `updates` branch to Platform.sh. By default, Platform.sh does not create an active environment for each development environment you push, so you will need to mmanually do so with the command:

      ```
      platform environment:activate updates
      ```

      You will then see the application's build log in your terminal. When it has completed, use the command `platform url` to go to the new development version of your application, and then follow the same steps you did before to register it.

      * click **Register GitHub App** and then **Create GitHub App**, choosing a name for the app like <PRODUCTION_APP_NAME>-dev.
      * update your `.environment` file for production (`export NODE_ENV=production), and push to the `updates` environment.
      * Go to your newly registered application's advanced settings and **Redeliver** the first ping GitHub tried to send to the Platform.sh environment.
      * After it succeeds, install the development app on *a different repository than the production app*. You should see that you have to allow new permissions for this version of the app.
      * Verify that the app writes a comment when you open a new issue.
